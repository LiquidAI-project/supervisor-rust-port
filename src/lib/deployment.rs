//! # deployment.rs
//!
//! Provides the core logic for deploying and orchestrating WebAssembly modules.
//!
//! This module defines data structures and utilities for:
//! - Configuring WebAssembly module runtimes
//! - Managing lifecycle-based file mounts (deployment, execution, output)
//! - Representing OpenAPI-compatible endpoint schemas
//! - Interpreting execution outputs and chaining calls across modules
//!
//! It also includes logic for parsing and validating mount definitions, linking function
//! endpoints, and preparing module invocations. 


use std::collections::{HashMap, HashSet};
use std::path::PathBuf;
use std::fmt::Debug;
use std::str::FromStr;
use std::fs::File;
use std::fs;
use serde_json::Value;
use serde::{Deserialize, Serialize};
use log::{error, warn, info};
use serde_json::Map;
use std::iter::Iterator;
use strum_macros::{EnumString, AsRefStr};
use wasmtime::{Val, ValType};
use crate::lib::constants::{PARAMS_FOLDER, FILE_TYPES};
use crate::lib::wasmtime::{WasmtimeRuntime, WasmtimeModule, ModuleConfig};

/// Represents the lifecycle stage at which a file is mounted into a module's execution context.
///
/// Mounts can occur during:
/// - `DEPLOYMENT`: Static data available before execution.
/// - `EXECUTION`: Runtime input files (e.g. POSTed by client).
/// - `OUTPUT`: Expected output paths generated by the module.
/// - `UNKNOWN`: Fallback when parsing fails.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, EnumString, AsRefStr, Serialize, Deserialize)]
pub enum MountStage {
    #[strum(serialize = "deployment")]
    #[serde(rename = "deployment")]
    DEPLOYMENT,
    #[strum(serialize = "execution")]
    #[serde(rename = "execution")]
    EXECUTION,
    #[strum(serialize = "output")]
    #[serde(rename = "output")]
    OUTPUT,
    #[strum(serialize = "unknown")]
    #[serde(rename = "unknown")]
    UNKNOWN,
}

impl From<String> for MountStage {
    fn from(s: String) -> Self {
        MountStage::from_str(&s).unwrap_or_else(|_| {
            error!("Invalid Stage: '{}', defaulting to UNKNOWN", s);
            MountStage::UNKNOWN
        })
    }
}

/// Represents a file path and its metadata, used for mounting into a Wasm module.
///
/// Each mount includes:
/// - `path`: Virtual mount path inside module
/// - `media_type`: MIME type (e.g. `image/png`)
/// - `stage`: Lifecycle stage this file is used in
/// - `required`: Whether the file is mandatory
/// - `encoding`: Data encoding (e.g. `base64`)
/// - `_type`: Type name (e.g. `string`, `binary`)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MountPathFile {
    pub path: String,
    pub media_type: String,
    pub stage: MountStage,
    #[serde(default = "default_required")]
    pub required: bool,
    #[serde(default = "default_encoding")]
    pub encoding: String,
    #[serde(default = "default_type")]
    pub r#type: String,
}

impl MountPathFile {
    /// Constructs a new `MountPathFile` with default fallbacks for optional fields.
    pub fn new<S: Into<MountStage>>(
        path: String,
        media_type: String,
        stage: S,
        required: Option<bool>,
        encoding: Option<String>,
        r#type: Option<String>,
    ) -> Self {
        MountPathFile {
            path,
            media_type,
            stage: stage.into(),
            required: required.unwrap_or(true),
            encoding: encoding.unwrap_or_else(|| "base64".to_string()),
            r#type: r#type.unwrap_or_else(|| "string".to_string()),
        }
    }

    /// Placeholder for validation logic (currently a passthrough).
    ///
    /// TODO: Determine if this function is necessary or should be removed.
    pub fn validate(&self, x: HashMap<String, Value>) -> HashMap<String, Value> {
        x
    }
}

// Helper default functions for serde
fn default_required() -> bool {
    true
}
fn default_encoding() -> String {
    "base64".to_string()
}
fn default_type() -> String {
    "string".to_string()
}

/// Represents the high-level type of a schema field (OpenAPI-compatible).
///
/// Types include:
/// - `INTEGER`: Numeric integer values
/// - `STRING`: Text or binary content
/// - `OBJECT`: JSON objects
/// - `UNKNOWN`: Fallback when parsing fails
#[derive(Debug, Clone, PartialEq, Eq, EnumString, AsRefStr, Serialize, Deserialize)]
pub enum SchemaType {
    #[strum(serialize = "integer")]
    #[serde(rename = "integer")]
    INTEGER,
    #[strum(serialize = "string")]
    #[serde(rename = "string")]
    STRING,
    #[strum(serialize = "object")]
    #[serde(rename = "object")]
    OBJECT,
    #[strum(serialize = "unknown")]
    #[serde(rename = "unknown")]
    UNKNOWN,
}

impl From<String> for SchemaType {
    fn from(s: String) -> Self {
        SchemaType::from_str(&s).unwrap_or_else(|_| {
            error!("Invalid SchemaType: '{}', defaulting to UNKNOWN", s);
            SchemaType::UNKNOWN
        })
    }
}

/// Represents the format of a schema field (e.g. encoding for strings or binary).
///
/// Formats include:
/// - `BINARY`: Raw binary content
/// - `UNKNOWN`: Fallback when parsing fails
#[derive(Debug, Clone, PartialEq, Eq, EnumString, AsRefStr, Serialize, Deserialize)]
pub enum SchemaFormat {
    #[strum(serialize = "binary")]
    #[serde(rename = "binary")]
    BINARY,
    #[strum(serialize = "unknown")]
    #[serde(rename = "unknown")]
    UNKNOWN,
}

impl From<String> for SchemaFormat {
    fn from(s: String) -> Self {
        SchemaFormat::from_str(&s).unwrap_or_else(|_| {
            error!("Invalid SchemaFormat: '{}', defaulting to UNKNOWN", s);
            SchemaFormat::UNKNOWN
        })
    }
}

/// Describes the structure and constraints of a media type's payload.
///
/// This structure is compatible with OpenAPI `schema` objects, and can represent:
/// - Primitive types (like string/integer)
/// - Binary payloads
/// - Nested properties (for objects)
#[derive(Debug, Serialize, Deserialize)]
pub struct Schema {
    /// The top-level type (e.g. string, object, etc.)
    pub r#type: SchemaType,

    /// Optional format (e.g. "binary") associated with the type
    pub format: Option<SchemaFormat>,

    /// Optional nested object properties (used for structured types)
    pub properties: Option<HashMap<String, HashMap<String, String>>>,
}

impl Schema {
    /// Constructs a new schema instance with optional format and nested properties.
    pub fn new<T: Into<SchemaType>, F: Into<Option<String>>>(
        r#type: T,
        format: F,
        properties: Option<HashMap<String, HashMap<String, String>>>,
    ) -> Self {
        let format_option: Option<SchemaFormat> = format.into().map(SchemaFormat::from);
        Schema {
            r#type: r#type.into(),
            format: format_option,
            properties,
        }
    }
}

impl From<HashMap<String, Value>> for Schema {
    /// Parses a schema from a raw JSON map (typically from deserialized input).
    ///
    /// Falls back to a default `UNKNOWN` schema on failure.
    fn from(map: HashMap<String, Value>) -> Self {
        match serde_json::from_value::<Schema>(Value::Object(map.into_iter().collect())) {
            Ok(schema) => schema,
            Err(e) => {
                error!("Failed to parse schema from map: {}", e);
                Schema::new(SchemaType::UNKNOWN, None, None)
            }
        }
    }
}

/// Describes a specific media type (like `application/json` or `image/png`)
/// along with its expected schema and optional encoding configuration.
///
/// This structure is aligned with the OpenAPI `MediaTypeObject` definition.
#[derive(Debug, Serialize, Deserialize)]
pub struct MediaTypeObject {
    /// MIME type of the payload (e.g. `"application/json"`)
    pub media_type: String,

    /// Schema describing the payload structure
    pub schema: Schema,

    /// Optional encoding hints (e.g. base64, gzip, etc.)
    pub encoding: Option<HashMap<String, HashMap<String, String>>>,
}

impl MediaTypeObject {
    /// Creates a new media type object with the given MIME type, schema, and encoding.
    pub fn new<S: Into<Schema>>(
        media_type: String,
        schema: S,
        encoding: Option<HashMap<String, HashMap<String, String>>>,
    ) -> Self {
        MediaTypeObject {
            media_type,
            schema: schema.into(),
            encoding,
        }
    }
}

impl From<HashMap<String, Value>> for MediaTypeObject {
    /// Attempts to parse a `MediaTypeObject` from a JSON map.
    ///
    /// If parsing fails, returns a fallback with `application/octet-stream` and `UNKNOWN` schema.
    fn from(map: HashMap<String, Value>) -> Self {
        match serde_json::from_value::<MediaTypeObject>(Value::Object(map.into_iter().collect())) {
            Ok(media_type) => media_type,
            Err(e) => {
                error!("Failed to parse MediaTypeObject (or EndpointResponse) from map: {}", e);
                MediaTypeObject::new(
                    "application/octet-stream".to_string(),
                    Schema::new(SchemaType::UNKNOWN, None, None),
                    None,
                )
            }
        }
    }
}


/// Describes the expected request structure for an HTTP-exposed Wasm function.
///
/// Includes parameter maps and an optional body schema.
#[derive(Debug, Serialize, Deserialize)]
pub struct EndpointRequest {
    /// List of parameter maps (typically query parameters).
    pub parameters: Vec<HashMap<String, Value>>,

    /// Optional body schema for POST requests or structured inputs.
    pub request_body: Option<MediaTypeObject>,
}

impl EndpointRequest {
    /// Constructs a new `EndpointRequest` from parameters and an optional body.
    pub fn new<P, R>(parameters: P, request_body: R) -> Self
    where
        P: Into<Vec<HashMap<String, Value>>>,
        R: Into<Option<HashMap<String, Value>>>,
    {
        let body_option: Option<MediaTypeObject> = request_body.into().map(MediaTypeObject::from);

        EndpointRequest {
            parameters: parameters.into(),
            request_body: body_option,
        }
    }
}

impl From<HashMap<String, Value>> for EndpointRequest {
    /// Attempts to deserialize an `EndpointRequest` from a raw JSON map.
    ///
    /// Returns an empty fallback if deserialization fails.
    fn from(map: HashMap<String, Value>) -> Self {
        let json_map: Map<String, Value> = map.into_iter().collect();
        serde_json::from_value::<EndpointRequest>(Value::Object(json_map)).unwrap_or_else(|e| {
            error!("Failed to parse EndpointRequest from map: {}", e);
            EndpointRequest::new(vec![], None)
        })
    }
}

/// Type alias for the response schema of an endpoint.
///
/// This is defined using `MediaTypeObject` for OpenAPI-style responses.
pub type EndpointResponse = MediaTypeObject;

/// Describes an HTTP-exposed Wasm function including its route, method, input and output schemas.
///
/// This structure defines how a function is invoked, what it accepts, and what it returns.
#[derive(Debug, Serialize, Deserialize)]
pub struct Endpoint {
    /// The base URL (e.g., `http://host`).
    pub url: String,

    /// The relative path to the function (e.g., `/run`).
    pub path: String,

    /// The HTTP method used (GET, POST, etc.).
    pub method: String,

    /// Request schema (parameters and optional body).
    pub request: EndpointRequest,

    /// Response schema including type and optional encoding.
    pub response: EndpointResponse,
}

impl Endpoint {
    /// Constructs a new endpoint with given URL, method, request schema, and response schema.
    pub fn new<R, S>(
        url: String,
        path: String,
        method: String,
        request: R,
        response: S,
    ) -> Self
    where
        R: Into<EndpointRequest>,
        S: Into<EndpointResponse>,
    {
        Endpoint {
            url,
            path,
            method,
            request: request.into(),
            response: response.into(),
        }
    }

    /// Validates an endpoint map. Currently a passthrough.
    ///
    /// # TODO
    /// Determine if this function serves a purpose or should be removed.
    pub fn validate(x: HashMap<String, Value>) -> HashMap<String, Value> {
        x
    }

    /// Opens any file paths listed in the `multipart/form-data` response schema.
    ///
    /// Returns a map of filename → file handle.
    pub fn open_response_files(&self) -> HashMap<String, File> {
        let mut files = HashMap::new();
        if self.response.media_type == "multipart/form-data" {
            let execution_files = get_supported_file_schemas(&self.response.schema, &self.response.encoding);
            for (path, _schema) in execution_files {
                match File::open(&path) {
                    Ok(file) => {
                        files.insert(path.clone(), file);
                    }
                    Err(e) => {
                        error!("Failed to open file '{}': {}", path, e);
                    }
                }
            }
        } else {
            error!(
                "Unsupported media type (fn open_response_files): {}",
                self.response.media_type
            );
        }
        files
    }
}

/// Extracts schema entries that represent file fields in multipart/form-data.
///
/// Filters for:
/// - Type `"string"`
/// - Format `"binary"`
/// - Encoding content-type must be a supported file type
pub fn get_supported_file_schemas(
    schema: &Schema,
    encoding: &Option<HashMap<String, HashMap<String, String>>>,
) -> Vec<(String, HashMap<String, String>)> {
    if let Some(props) = &schema.properties {
        props
            .iter()
            .filter(|(path, sub_schema)| {
                sub_schema.get("type").map(String::as_str) == Some("string")
                    && sub_schema.get("format").map(String::as_str) == Some("binary")
                    && encoding
                        .as_ref()
                        .and_then(|enc| enc.get(*path))
                        .and_then(|map| map.get("contentType"))
                        .map(|ctype| FILE_TYPES.contains(&ctype.as_str()))
                        .unwrap_or(false)
            })
            .map(|(path, sub_schema)| (path.clone(), sub_schema.clone()))
            .collect()
    } else {
        vec![]
    }
}

/// Represents the kinds of inputs that can be passed to a Wasm function.
///
/// Used internally to pass arguments to the runtime.
#[derive(Debug, Clone)]
pub enum EndpointArgs {
    /// Single string argument (scalar).
    Str(String),
    /// Ordered list of string arguments.
    StrList(Vec<String>),
    /// Structured dictionary of string keys and JSON values.
    Dict(HashMap<String, Value>),
}

impl From<String> for EndpointArgs {
    fn from(s: String) -> Self {
        EndpointArgs::Str(s)
    }
}

impl From<Vec<String>> for EndpointArgs {
    fn from(v: Vec<String>) -> Self {
        EndpointArgs::StrList(v)
    }
}

impl From<HashMap<String, Value>> for EndpointArgs {
    fn from(d: HashMap<String, Value>) -> Self {
        EndpointArgs::Dict(d)
    }
}

/// Represents output data from a Wasm function execution, such as file paths.
///
/// This typically includes paths to output files created by the function.
#[derive(Debug, Clone)]
pub enum EndpointData {
    /// List of file paths (as strings).
    StrList(Vec<String>),
}

impl From<Vec<String>> for EndpointData {
    fn from(v: Vec<String>) -> Self {
        EndpointData::StrList(v)
    }
}

/// Combined output of a function execution, including:
/// - Optional next call arguments (`EndpointArgs`)
/// - Optional output files (`EndpointData`)
pub type EndpointOutput = (Option<EndpointArgs>, Option<EndpointData>);

/// Describes the next function call in a chain, along with HTTP request details.
///
/// Used when chaining Wasm module functions by interpreting `Endpoint` definitions.
#[derive(Debug)]
pub struct CallData {
    /// Full URL to call (including any query parameters).
    pub url: String,
    /// HTTP headers to attach to the request (currently unused).
    pub headers: HashMap<String, String>,
    /// HTTP method (GET, POST, etc.).
    pub method: String,
    /// Output files from the previous function call to be sent with this one.
    pub files: EndpointData,
}

impl CallData {
    /// Builds a `CallData` instance from a given `Endpoint`, arguments, and output files.
    ///
    /// Arguments are converted into query parameters depending on their type:
    /// - `Str` → single query string
    /// - `StrList` → sequential param-value pairs
    /// - `Dict` → key-value mapping to query parameters
    pub fn from_endpoint(
        endpoint: &Endpoint,
        args: Option<EndpointArgs>,
        files: Option<EndpointData>,
    ) -> Self {
        let mut url = format!("{}{}", endpoint.url.trim_end_matches('/'), endpoint.path);
        let headers = HashMap::new();

        if let Some(args) = args {
            let query = match args {
                EndpointArgs::Str(s) => {
                    let param_name = endpoint.request.parameters.get(0)
                        .and_then(|p| p.get("name"))
                        .and_then(|n| n.as_str())
                        .unwrap_or("param");
                    format!("?{}={}", param_name, s)
                }
                EndpointArgs::StrList(lst) => {
                    let params: Vec<String> = endpoint.request.parameters.iter()
                        .zip(lst.iter())
                        .filter_map(|(param_map, value)| {
                            param_map.get("name").and_then(|name| {
                                name.as_str().map(|n| format!("{}={}", n, value))
                            })
                        })
                        .collect();
                    if !params.is_empty() {
                        format!("?{}", params.join("&"))
                    } else {
                        String::new()
                    }
                }
                EndpointArgs::Dict(map) => {
                    let params: Vec<String> = endpoint.request.parameters.iter()
                        .filter_map(|param_map| {
                            param_map.get("name").and_then(|name| {
                                let key = name.as_str()?;
                                map.get(key).map(|v| format!("{}={}", key, v))
                            })
                        })
                        .collect();
                    if !params.is_empty() {
                        format!("?{}", params.join("&"))
                    } else {
                        String::new()
                    }
                }
            };
            url.push_str(&query);
        }

        let file_list = files.unwrap_or_else(|| EndpointData::StrList(vec![]));

        // Force POST if files are present in the request
        let method = match &file_list {
            EndpointData::StrList(list) if !list.is_empty() => "POST".to_string(),
            _ => endpoint.method.clone(),
        };

        CallData {
            url,
            headers,
            method,
            files: file_list,
        }
    }
}

/// Represents a link (call chain) between two Wasm function endpoints.
///
/// Used in instruction graphs to describe function chaining behavior.
#[derive(Debug)]
pub struct FunctionLink {
    /// The source function that triggers the next one.
    pub from: Endpoint,
    /// The destination function (optional if terminal call).
    pub to: Option<Endpoint>,
}

impl FunctionLink {
    /// Constructs a `FunctionLink` from two endpoints.
    pub fn new(from: Endpoint, to: Option<Endpoint>) -> Self {
        FunctionLink { from, to }
    }
}

impl From<HashMap<String, Value>> for FunctionLink {
    /// Attempts to deserialize a `FunctionLink` from a JSON-style map.
    ///
    /// The map must contain at least a `"from_"` key with valid `Endpoint` data.
    /// If `from_` is missing or invalid, a fallback default is used and logged.
    fn from(map: HashMap<String, Value>) -> Self {
        let from = map.get("from_")
            .and_then(|v| serde_json::from_value::<Endpoint>(v.clone()).ok())
            .unwrap_or_else(|| {
                error!("Invalid or missing 'from_' field in FunctionLink");
                Endpoint::new(
                    "".to_string(),
                    "".to_string(),
                    "".to_string(),
                    EndpointRequest::new(vec![], None),
                    EndpointResponse::new(
                        "application/octet-stream".to_string(),
                        Schema::new(SchemaType::UNKNOWN, None, None),
                        None,
                    ),
                )
            });

        let to = map.get("to")
            .and_then(|v| serde_json::from_value::<Endpoint>(v.clone()).ok());

        FunctionLink { from, to }
    }
}

// --------------------------------------------------------------------------------------------------
// Type Aliases - Simplify nested map structures representing modules and their metadata.
// --------------------------------------------------------------------------------------------------

/// Maps function names to their Endpoint definitions for a single module.
pub type FunctionEndpointMap = HashMap<String, Endpoint>;

/// Maps module names to function endpoint maps.
pub type ModuleEndpointMap = HashMap<String, FunctionEndpointMap>;

/// Maps function names to how they are linked to other functions.
pub type FunctionLinkMap = HashMap<String, FunctionLink>;

/// Maps module names to function link maps (i.e. call graphs).
pub type ModuleLinkMap = HashMap<String, FunctionLinkMap>;

/// Maps mount stages to mount path definitions.
pub type MountStageMap = HashMap<MountStage, Vec<MountPathFile>>;

/// Maps function names to stage-based mount definitions.
pub type FunctionMountMap = HashMap<String, MountStageMap>;

/// Maps module names to their function mount definitions.
pub type ModuleMountMap = HashMap<String, FunctionMountMap>;

/// Represents a complete WebAssembly deployment, including all modules, runtimes,
/// mount definitions, and function call graphs.
///
/// A `Deployment` contains all the metadata and configuration necessary to:
/// - Load and initialize Wasm modules into runtime environments
/// - Configure HTTP-exposed functions and endpoint schemas
/// - Define mount paths and file access per module and execution stage
/// - Chain function calls across modules based on user-defined instructions
///
/// This structure mirrors the behavior of the original Python `deployment.py` system.
#[derive(Debug)]
pub struct Deployment {
    /// ID of the deployment (may be used for namespacing or identification).
    pub id: String,

    /// WebAssembly runtimes loaded and associated with modules.
    pub runtimes: HashMap<String, WasmtimeRuntime>,

    /// The initial module configs (before parsing into indexed map).
    pub _modules: Vec<ModuleConfig>,

    /// HTTP endpoints defined for each function in each module.
    pub endpoints: ModuleEndpointMap,

    /// Raw instruction data (usually parsed into `instructions`).
    pub _instructions: HashMap<String, Value>,

    /// Raw mount data (usually parsed into `mounts`).
    pub _mounts: HashMap<String, Value>,

    /// Parsed module configs by name.
    pub modules: HashMap<String, ModuleConfig>,

    /// Parsed call graph of module functions.
    pub instructions: ModuleLinkMap,

    /// Parsed mapping of all mount paths for all functions.
    pub mounts: ModuleMountMap,
}

impl Deployment {
    /// Constructs a new `Deployment` instance and initializes its internal maps.
    ///
    /// - `id`: A string identifier for this deployment.
    /// - `runtimes`: The collection of Wasmtime runtimes, one per module.
    /// - `module_configs`: Original list of module configurations (used to fill `modules`).
    /// - `endpoints`: HTTP endpoints describing how each module function is called.
    /// - `instructions`: Call graph and chaining instructions.
    /// - `mounts`: Describes all expected input/output files for each function.
    pub fn new(
        id: String,
        runtimes: HashMap<String, WasmtimeRuntime>,
        module_configs: Vec<ModuleConfig>,
        endpoints: ModuleEndpointMap,
        instructions: HashMap<String, Value>,
        mounts: HashMap<String, Value>,
    ) -> Self {
        let mut this = Deployment {
            id,
            runtimes,
            _modules: module_configs,
            endpoints,
            _instructions: instructions,
            _mounts: mounts,
            modules: HashMap::new(),
            instructions: HashMap::new(),
            mounts: HashMap::new(),
        };
        this.init();
        this
    }

    /// Initializes the deployment:
    /// - Maps `_modules` to the `modules` field.
    /// - Parses raw `_mounts` into `MountPathFile`s for each function stage.
    /// - Parses `_instructions` into a call graph of `FunctionLink`s.
    fn init(&mut self) {
        // Build module name → config map
        for m in &self._modules {
            self.modules.insert(m.name.clone(), m.clone());
        }

        // Parse file mounts for each function and stage (DEPLOYMENT, EXECUTION, OUTPUT)
        for (module_name, functions) in &self._mounts {
            if let Value::Object(fn_map) = functions {
                let mut function_mounts = HashMap::new();
                for (function_name, stage_mounts) in fn_map {
                    if let Value::Object(stage_map) = stage_mounts {
                        let mut stage_mounts_parsed = HashMap::new();
                        for (stage, mounts) in stage_map {
                            if let Value::Array(mount_list) = mounts {
                                let parsed_mounts: Vec<MountPathFile> = mount_list
                                    .iter()
                                    .filter_map(|m| serde_json::from_value::<MountPathFile>(m.clone()).ok())
                                    .collect();
                                stage_mounts_parsed.insert(MountStage::from(stage.clone()), parsed_mounts);
                            }
                        }
                        function_mounts.insert(function_name.clone(), stage_mounts_parsed);
                    }
                }
                self.mounts.insert(module_name.clone(), function_mounts);
            }
        }

        // Parse instruction links (how to chain calls between modules/functions)
        if let Some(Value::Object(modules)) = self._instructions.get("modules") {
            for (module_name, functions) in modules {
                if let Value::Object(fn_map) = functions {
                    let mut function_links = HashMap::new();
                    for (function_name, link) in fn_map {
                        if let Value::Object(link_map) = link {
                            let from = link_map.get("from")
                                .and_then(|v| serde_json::from_value::<Endpoint>(v.clone()).ok());
                            let to = link_map.get("to")
                                .and_then(|v| serde_json::from_value::<Endpoint>(v.clone()).ok());
                            if let Some(from_endpoint) = from {
                                function_links.insert(
                                    function_name.clone(),
                                    FunctionLink { from: from_endpoint, to },
                                );
                            } else {
                                error!("Skipping function link for {}/{}: Missing 'from' field", module_name, function_name);
                            }
                        }
                    }
                    self.instructions.insert(module_name.clone(), function_links);
                }
            }
        } else {
            warn!("No 'modules' key found in `_instructions`. Using empty instructions.");
        }
    }

    /// Return the next function's endpoint (if any) that this function is supposed to call.
    ///
    /// Returns `None` if this is the terminal function.
    pub fn _next_target(&self, module_name: &str, function_name: &str) -> Option<&Endpoint> {
        let mod_map = self.instructions.get(module_name)
            .expect(&format!("Module '{}' not found in instructions", module_name));
        let link = mod_map.get(function_name)
            .expect(&format!("Function '{}' not found in module '{}'", function_name, module_name));
        link.to.as_ref()
    }

    /// Validates and sets up file mounts for a module function before execution.
    ///
    /// - Checks that required files are present.
    /// - Ensures correct mount paths and stages (DEPLOYMENT, EXECUTION).
    /// - Copies input files into their correct mounted location if necessary.
    ///
    /// This sets up the module's environment so it can access inputs via WASI.
    pub fn _connect_request_files_to_mounts(
        &self,
        module_name: &str,
        function_name: &str,
        request_filepaths: &HashMap<String, PathBuf>,
    ) -> Result<(), String> {
        let mounts = self.mounts.get(module_name)
            .and_then(|mod_map| mod_map.get(function_name))
            .ok_or_else(|| format!("No mounts found for module '{}/{}'", module_name, function_name))?;

        let empty_vec: Vec<MountPathFile> = vec![];

        let deployment_stage_mount_paths = mounts.get(&MountStage::DEPLOYMENT).unwrap_or(&empty_vec);
        let execution_stage_mount_paths = mounts.get(&MountStage::EXECUTION).unwrap_or(&empty_vec);

        // Keep track of all input paths already seen.
        let mut received_filepaths: HashSet<String> = deployment_stage_mount_paths.iter()
            .map(|mount| mount.path.clone())
            .collect();

        for (request_mount_path, temp_source_path) in request_filepaths {
            // Verify the file was expected during EXECUTION stage.
            if !execution_stage_mount_paths.iter().any(|mount| mount.path == *request_mount_path) {
                return Err(format!("Unexpected input file: {}", request_mount_path));
            }
            // Ensure no duplicate mappings
            if !received_filepaths.insert(request_mount_path.clone()) {
                return Err(format!(
                    "Input file '{}' already mapped to '{}'", 
                    temp_source_path.display(), 
                    request_mount_path
                ));
            }
        }

        // Determine required input files across both DEPLOYMENT and EXECUTION
        let required_input_mount_paths: HashSet<String> = deployment_stage_mount_paths.iter()
            .chain(execution_stage_mount_paths.iter())
            .filter(|mount| mount.required)
            .map(|mount| mount.path.clone())
            .collect();

        let missing_files: Vec<&String> = required_input_mount_paths.difference(&received_filepaths).collect();
        if !missing_files.is_empty() {
            return Err(format!("Required input files missing: {:?}", missing_files));
        }

        let output_stage_mount_paths = mounts.get(&MountStage::OUTPUT).unwrap_or(&empty_vec);
        let all_mounts = deployment_stage_mount_paths.iter()
            .chain(execution_stage_mount_paths.iter())
            .chain(output_stage_mount_paths.iter());

        // Copy input files to expected mount paths
        for mount in all_mounts {
            let temp_source_path = match mount.stage {
                MountStage::DEPLOYMENT => {
                    self.modules.get(module_name)
                        .and_then(|module| module.data_files.get(&mount.path))
                        .map(|s| PathBuf::from(s))
                }
                MountStage::EXECUTION => {
                    request_filepaths.get(&mount.path).cloned()
                }
                MountStage::OUTPUT => continue,
                _ => continue,
            };

            let Some(temp_source_path) = temp_source_path else {
                error!("Module expects mount '{}', but it was not found in request or deployment.", mount.path);
                return Err(format!("Missing input file: {}", mount.path));
            };

            let host_path = module_mount_path(module_name, &mount.path);
            if host_path != temp_source_path {
                match fs::copy(&temp_source_path, &host_path) {
                    Ok(_) => {},
                    Err(e) => {
                        error!("Failed to copy '{}' to '{}': {}", temp_source_path.display(), host_path.display(), e);
                        return Err(format!("Failed to move file: {}", temp_source_path.display()));
                    }
                }
            } else {
                warn!("File already at mount location: {}", host_path.display());
            }
        }
        Ok(())
    }

    /// Prepares a module and its function for execution:
    /// - Ensures mounts are connected correctly.
    /// - Loads the module into its runtime.
    /// - Converts function arguments into WebAssembly primitive values.
    ///
    /// Returns the instantiated module and list of WASM `Val`s as arguments.
    pub async fn prepare_for_running(
        &mut self,
        module_name: &str,
        function_name: &str,
        args: &HashMap<String, Value>,
        request_filepaths: &HashMap<String, String>,
    ) -> Result<(WasmtimeModule, Vec<Val>), String> {
        let path_map: HashMap<String, PathBuf> = request_filepaths
            .iter()
            .map(|(k, v)| (k.clone(), PathBuf::from(v)))
            .collect();

        self._connect_request_files_to_mounts(module_name, function_name, &path_map)
            .map_err(|e| format!("Mount error: {}", e))?;

        let config = self.modules
            .get(module_name)
            .ok_or_else(|| format!("Module '{}' not found in self.modules", module_name))?;

        let runtime = self.runtimes
            .get_mut(module_name)
            .ok_or_else(|| format!("Runtime for module '{}' not found", module_name))?;

        runtime.load_module(config.clone()).await
            .map_err(|e| format!("Failed to load module: {}", e))?;

        let arg_types = runtime.get_arg_types(module_name, function_name).await; // TODO: Is this an issue to do at this point or not?

        let module = runtime.get_module(module_name).await
            .ok_or_else(|| format!("Module '{}' not found after load", module_name))?;

        // Convert arguments from serde_json::Value → wasmtime::Val based on type hints.
        let primitive_args: Vec<Val> = args.values()
            .zip(arg_types.iter())
            .map(|(value, typ)| match typ {
                ValType::I32 => {
                    match value {
                        Value::Number(num) => Val::I32(num.as_i64().unwrap_or_default() as i32),
                        Value::String(s) => s.parse::<i32>().map(Val::I32).unwrap_or(Val::I32(0)),
                        _ => Val::I32(0),
                    }
                }
                ValType::I64 => {
                    match value {
                        Value::Number(num) => Val::I64(num.as_i64().unwrap_or_default()),
                        Value::String(s) => s.parse::<i64>().map(Val::I64).unwrap_or(Val::I64(0)),
                        _ => Val::I64(0),
                    }
                }
                ValType::F32 => {
                    match value {
                        Value::Number(num) => Val::F32((num.as_f64().unwrap_or_default() as f32).to_bits()),
                        Value::String(s) => s.parse::<f32>().map(|f| Val::F32(f.to_bits())).unwrap_or(Val::F32(0)),
                        _ => Val::F32(0),
                    }
                }
                ValType::F64 => {
                    match value {
                        Value::Number(num) => Val::F64(num.as_f64().unwrap_or_default().to_bits()),
                        Value::String(s) => s.parse::<f64>().map(|f| Val::F64(f.to_bits())).unwrap_or(Val::F64(0)),
                        _ => Val::F64(0),
                    }
                }
                _ => {
                    error!("Unsupported argument type: {:?}", typ);
                    Val::I32(0)
                }
            })
            .collect();
        Ok((module.clone(), primitive_args))
    }

    /// Interprets the output from a Wasm function call and determines the next call (if any).
    ///
    /// Returns:
    /// - Parsed result as `(EndpointArgs, EndpointData)`
    /// - Optional `CallData` describing how to invoke the next endpoint.
    pub fn interpret_call_from(
        &self,
        module_name: &str,
        function_name: &str,
        wasm_output: Value,
    ) -> (EndpointOutput, Option<CallData>) {
        let endpoint = &self.endpoints[module_name][function_name];
        let output_mounts = self
            .mounts
            .get(module_name)
            .and_then(|m| m.get(function_name))
            .and_then(|sm| sm.get(&MountStage::OUTPUT))
            .cloned()
            .unwrap_or_default();

        let parsed = self.parse_endpoint_result(wasm_output, &endpoint.response, &output_mounts);

        if let Some(next_ep) = self._next_target(module_name, function_name) {
            let cd = CallData::from_endpoint(next_ep, parsed.0.clone(), parsed.1.clone());
            (parsed, Some(cd))
        } else {
            (parsed, None)
        }
    }

    /// Translates a WebAssembly function's output value into the expected OpenAPI-like format.
    ///
    /// If the output is:
    /// - JSON: return as string or empty object.
    /// - Binary (e.g., image): return file path(s) from output mount.
    /// - Anything else: log error and return empty.
    pub fn parse_endpoint_result(
        &self,
        wasm_output: Value,
        response_endpoint: &MediaTypeObject,
        output_mounts: &Vec<MountPathFile>,
    ) -> EndpointOutput {
        match response_endpoint.media_type.as_str() {
            "application/json" => {
                if can_be_represented_as_wasm_primitive(&response_endpoint.schema) {
                    (
                        Some(EndpointArgs::Str(wasm_output.to_string())),
                        None,
                    )
                } else {
                    (
                        Some(EndpointArgs::Dict(HashMap::new())),
                        None,
                    )
                }
            }
            mt if FILE_TYPES.contains(&mt) => {
                if output_mounts.len() == 1 {
                    (
                        None,
                        Some(EndpointData::StrList(vec![output_mounts[0].path.clone()])),
                    )
                } else {
                    error!(
                        "Expected 1 output mount for media type '{}', found {}",
                        mt,
                        output_mounts.len()
                    );
                    (None, None)
                }
            }
            _ => {
                error!("Unsupported media type: {}", response_endpoint.media_type);
                (None, None)
            }
        }
    }
}

/// Determines if a given schema can be represented by a primitive WebAssembly value.
/// 
/// Currently only checks for integer types, since they're directly mappable to WASM `i32` or `i64`.
///
/// # Arguments
/// * `schema` - The OpenAPI-style schema describing the output format.
///
/// # Returns
/// * `true` if the type is compatible with WASM primitive representation.
pub fn can_be_represented_as_wasm_primitive(schema: &Schema) -> bool {
    matches!(schema.r#type, SchemaType::INTEGER)
}

/// Builds the absolute host path for a file mounted into a specific module.
/// 
/// Used to resolve where a mounted file should live on the host filesystem (e.g. under `params/`).
///
/// # Arguments
/// * `module_name` - Name of the module the file belongs to.
/// * `filename` - The relative path (mount path) used within the module.
///
/// # Returns
/// * `PathBuf` pointing to the correct location on disk.
pub fn module_mount_path(module_name: &str, filename: &str) -> PathBuf {
    PARAMS_FOLDER.join(module_name).join(filename)
}
